#include "includes/stdlib.func";
#include "includes/errors.func";
#include "includes/op_codes.func";
#include "includes/constants.func";

#include "includes/usdt_utils.func";
#include "includes/jetton_utils.func";

global slice init::owner_address;
global slice init::admin_address;
global slice init::book_minter_address;

global cell init::usdt_wallet_code;
global cell init::soxo_wallet_code;

global cell glob::porder_queues;

global slice glob::usdt_master_address;
global slice glob::soxo_master_address;

global int glob::usdt_balance;
global int glob::soxo_jetton_balance;
global int glob::trading_session_price; ;; * 1000

global int glob::ffreeze;

int load_globals( ) impure {
    slice smc_storage =         get_data().begin_parse();

    glob::ffreeze =             smc_storage~load_int(FFREZE_LEN);
    slice addrs_ref =           smc_storage~load_ref().begin_parse();

    slice addrs1 =              addrs_ref~load_ref().begin_parse();
    slice addrs2 =              addrs_ref~load_ref().begin_parse();

    init::owner_address =       addrs1~load_msg_addr();
    init::admin_address =       addrs1~load_msg_addr();

    init::book_minter_address = addrs2~load_msg_addr();
    init::usdt_wallet_code    = addrs2~load_ref();
    init::soxo_wallet_code    = addrs2~load_ref();

    if (smc_storage.slice_bits() > 0) | (smc_storage.slice_refs() > 0) {
        glob::porder_queues =       smc_storage~load_dict();

        slice jw_addresses =        smc_storage~load_ref().begin_parse();
        glob::usdt_master_address = jw_addresses~load_msg_addr();
        glob::soxo_master_address = jw_addresses~load_msg_addr();

        slice conis_info =            jw_addresses~load_ref().begin_parse();
        glob::usdt_balance =          conis_info~load_coins();
        glob::soxo_jetton_balance =   conis_info~load_coins();
        glob::trading_session_price = conis_info~load_coins();

        return TRUE;
    } else {
        glob::porder_queues =         null();

        glob::usdt_master_address =   null();
        glob::soxo_master_address =   null();

        glob::usdt_balance =          null();
        glob::soxo_jetton_balance =   null();
        glob::trading_session_price = null();

        return FALSE;
    }
}

() set_globals( ) impure {
    set_data(
        begin_cell()

            .store_int(glob::ffreeze, FFREZE_LEN)
            .store_ref(
                begin_cell()
                    .store_ref(
                        begin_cell()
                            .store_slice(init::owner_address)
                            .store_slice(init::admin_address)
                        .end_cell()
                    )
                    .store_ref(
                        begin_cell()
                            .store_slice(init::book_minter_address)
                            .store_ref(init::usdt_wallet_code)
                            .store_ref(init::soxo_wallet_code)
                        .end_cell()
                    )
                .end_cell()
            )

            .store_dict(glob::porder_queues)

            .store_ref(
                begin_cell()
                    .store_slice(glob::usdt_master_address)
                    .store_slice(glob::soxo_master_address)
                    .store_ref(
                        begin_cell()
                            .store_coins(glob::usdt_balance)
                            .store_coins(glob::soxo_jetton_balance)
                            .store_coins(glob::trading_session_price)
                        .end_cell()
                    )
                .end_cell()
            )
        .end_cell()
    );
}

() send_jetton_ordinary( cell ctx_si, slice to_owner_address, int jetton_amount, int query_id, int jflag ) impure {

    slice jw_address = null();

    if jflag == 1 {
        jw_address = soxo::calculate_jetton_wallet_address(ctx_si);
    } elseif jflag == 2 {
        jw_address = usdt::calculate_jetton_wallet_address(ctx_si);
    } else {
        throw(99);
    }
    
    builder message = 
        begin_cell()
            .store_uint(BOUNCEABLE, 6)
            .store_slice(jw_address)
            .store_coins(50000000)          ;; 0.05 TON
            .store_statinit_ref_and_body_ref(
                ctx_si,
                begin_cell()
                    .store_op(op::jetton::transfer) 
                    .store_query_id(query_id)

                    .store_coins(jetton_amount)
                    .store_slice(to_owner_address)  ;; to_owner_address
                    .store_uint(0, 2)               ;; response_address
                    .store_int(0, 1)                ;; empty custom_payload
                    .store_coins(0)                 ;; forward amount to new_owner_address
                    .store_int(0, 1)                ;; empty forward_payload
                .end_cell()
            );

    send_raw_message(message.end_cell(), SEND_MODE_PAY_FEES_SEPARATELY);
}

slice construct_slice_addr( int std_addr ) inline {
    return (
        begin_cell()
            .store_uint(2, 2) 
            .store_uint(0, 1) 
            .store_uint(BASECHAIN, 8) 
            .store_uint(std_addr, 256)
        .end_cell().begin_parse()
    );
}

( cell, int, int, cell, int, int ) extract_asks_bids( int priority ) impure inline {
    (slice ctx_priority_queues, int ok) = glob::porder_queues.udict_get?(ORDER_QUEUES_KEY_LEN, priority);
    throw_unless(51, ok);
    return (
        ctx_priority_queues~load_dict(), 
        ctx_priority_queues~load_uint(ASKS_BIDS_NUMBER_LEN),
        ctx_priority_queues~load_uint(ASKS_BIDS_ID_LEN),
        ctx_priority_queues~load_dict(),
        ctx_priority_queues~load_uint(ASKS_BIDS_NUMBER_LEN),
        ctx_priority_queues~load_uint(ASKS_BIDS_ID_LEN)
        
    );
}

() pack_asks_bids( int priority, cell asks, int asks_number, int ask_id, cell bids, int bids_number, int bid_id ) impure inline {
    glob::porder_queues = glob::porder_queues.udict_set_builder(
        ORDER_QUEUES_KEY_LEN, priority,
            begin_cell()
                .store_dict(asks)
                .store_uint(asks_number, ASKS_BIDS_NUMBER_LEN)
                .store_uint(ask_id, ASKS_BIDS_ID_LEN)

                .store_dict(bids)
                .store_uint(bids_number, ASKS_BIDS_NUMBER_LEN)
                .store_uint(bid_id, ASKS_BIDS_ID_LEN)
    );
}

;; выпалта за BID - отправялем USDT(1)
;; выплата за ASK - отправляем SOXO(2)

{-
    glob::porder_queues
    │
    ├── 0
    ├── 1
    ├── 2
    ├── ...
    ├── ...
    ├── ...
    └── PRIORITIES_NUMBER
        │
        ├── asks 
        │   ├── key:   int --> std_addr
        │   └── value: builder --> coins
        │
        ├── asks_number: int 
        │
        │── bids
        │    ├── key:   int --> std_addr
        │    └── value: builder --> coins
        │
        └── bids_number: int
        

-}

int get_usdt( int soxo_amount ) inline {
    return ((soxo_amount * glob::trading_session_price) / TSP_DIVIDER);
}

int get_soxo( int usdt_amount ) inline {
    return ((usdt_amount * TSP_DIVIDER) / glob::trading_session_price);
}


() execute_orders( cell orders_dict, int qi ) impure {

    int success = TRUE;
    int addr_pivot = -1;

    do {   
        ( addr_pivot, slice order_info, success ) = orders_dict.udict_get_next?(STD_ADDR_LEN, addr_pivot);

        if success {   
            cell ctx_si = begin_cell().end_cell();

            int order_type = order_info~load_uint(ORDER_ID_LEN);
            int order_amount = order_info~load_coins();

            slice user_address = construct_slice_addr(addr_pivot);

            int jflag = 0;

            if order_type == BID_ID {
                ;; usdt::calculate_jetton_wallet_state_init for mainnet
                cell usdt_si = soxo::calculate_jetton_wallet_state_init(my_address(), glob::usdt_master_address, init::usdt_wallet_code);
                
                ctx_si = usdt_si;
                order_amount = order_amount / USDT_MULTIPLIER; 

                glob::usdt_balance -= order_amount;

                ;; 5 · Integer out of expected range
                throw_if(error::usdt_balance_overflow, glob::usdt_balance < 0);

                jflag = 1;

            } else {
                cell soxo_si = soxo::calculate_jetton_wallet_state_init(my_address(), glob::soxo_master_address, init::soxo_wallet_code);
                ctx_si = soxo_si;

                glob::soxo_jetton_balance -= order_amount;

                ;; 5 · Integer out of expected range
                throw_if(error::soxo_balance_overflow, glob::soxo_jetton_balance < 0);

                jflag = 2;
            }

            send_jetton_ordinary(ctx_si, user_address, order_amount, qi, jflag);
        }

    } until( ~ success );
}

;; тут разраешются ASK(запрос покупки SOXO за USDT), то есть на выходе в 
;; идеальном случае тому, кто сделал ASK - перейдут SOXO, а всем BID, которые этот ASK покрыли - USDT

( cell, int ) check_bids( cell resulting_orders_dict, int ask_usdt_amount ) impure {

    int ctx_priority = 1;
    int iterable_ask_usdt_amount = ask_usdt_amount;
    
    ;; iterate over all priorities

    while ( ctx_priority <= PRIORITIES_NUMBER ) {
        ;; priorities[iter]
        ( cell asks, int asks_number, int ask_id, cell ctx_bids, int ctx_bids_number, int ctx_bid_id ) = extract_asks_bids(ctx_priority);

        if ctx_bids_number != 0 {

            ;; iterate over all bids of this prtiority
            int ppivot = -1;
            int success = TRUE;
            
            ;; bids[iter]
            do {
                ( ppivot, slice bid_info, success ) = ctx_bids.udict_get_next?(ASKS_BIDS_NUMBER_LEN, ppivot);

                if success {
                    int ctx_soxo_bid_amount = bid_info~load_coins();
                    int ctx_std_addr = bid_info~load_uint(STD_ADDR_LEN);

                    int converted_ctx_soxo_bid_amount = get_usdt(ctx_soxo_bid_amount);
                    ;;       =           10_000_000_000 -                10_000_000_000
                    int dist = iterable_ask_usdt_amount - converted_ctx_soxo_bid_amount;

                    ;; perfect fit!
                    if dist == 0 { ;; лучший вариант, текущий BID идеально покрыл оставшийся ASK => останваоиваем поиски, мы полностью покрыи наш ASK!

                        ;; добавялем в спсиок тех, кому надо отправить USDT за их BID, 
                        ;; так как их SOXO, которые они отдали контакру, чтобы сделать этот BID - уйдут тому, чей ASK покрывается в этом цикле

                        ( slice ctx_info, int exists ) = resulting_orders_dict.udict_get?(STD_ADDR_LEN, ctx_std_addr);
                        if exists {
                            int order_id = ctx_info~load_uint(ORDER_ID_LEN);
                            int previous_coins_amount = ctx_info~load_coins();

                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(order_id, ORDER_ID_LEN).store_coins(converted_ctx_soxo_bid_amount + previous_coins_amount)
                            ); 
                        } else {
                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(BID_ID, ORDER_ID_LEN).store_coins(converted_ctx_soxo_bid_amount)
                            ); 
                        }

                        ;; удаляем этот BID и уменьшаем счётчик количества BID'ов, так как полностью покрыли его нашим ASK
                        ( ctx_bids, int suc ) = ctx_bids.udict_delete?(ASKS_BIDS_NUMBER_LEN, ppivot);
                        throw_unless(error:no_comments, suc);

                        ctx_bids_number -= 1;
                        ;; уменьшаем объём ask'a (обнуляем)
                        iterable_ask_usdt_amount -= converted_ctx_soxo_bid_amount;

                        pack_asks_bids(ctx_priority, asks, asks_number, ask_id, ctx_bids, ctx_bids_number, ctx_bid_id);

                        ;; выходим из цикла, так как мы уже покрыли ASK
                        success = FALSE;
                        ;; заканчиваем и глобальный цикл, который перебирает приоритеты
                        ctx_priority = PRIORITIES_NUMBER + 42;

                    } elseif dist > 0 { ;; значит, что текущий BID мы берём, но его не достаточно для покрытия всего ASK => идём искать дальше

                        ;; добавялем в спсиок тех, кому надо отправить USDT за их BID, 
                        ( slice ctx_info, int exists ) = resulting_orders_dict.udict_get?(STD_ADDR_LEN, ctx_std_addr);
                        if exists {
                            int order_id = ctx_info~load_uint(ORDER_ID_LEN);
                            int previous_coins_amount = ctx_info~load_coins();

                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(order_id, ORDER_ID_LEN).store_coins(converted_ctx_soxo_bid_amount + previous_coins_amount)
                            ); 
                        } else {
                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(BID_ID, ORDER_ID_LEN).store_coins(converted_ctx_soxo_bid_amount)
                            ); 
                        }

                        ;; удаляем этот BID и уменьшаем счётчик количества BID'ов, так как полностью покрыли его нашим ASK
                        ( ctx_bids, int suc ) = ctx_bids.udict_delete?(ASKS_BIDS_NUMBER_LEN, ppivot);
                        throw_unless(error:no_comments, suc);

                        ctx_bids_number -= 1;

                        ;; уменьшаем объём ask'a
                        iterable_ask_usdt_amount -= converted_ctx_soxo_bid_amount;

                        pack_asks_bids(ctx_priority, asks, asks_number, ask_id, ctx_bids, ctx_bids_number, ctx_bid_id);

                        ;; но мы идём дальше, чтобы постараться покрыть ASK полностью

                    } else { ;; dist < 0 (значит текущий BID с запасом покрывает оставшийся ASK)

                        ;; добавялем в спсиок тех, кому надо отправить USDT за их BID, НО! 
                        ;; добавляем ему не полный его BID, а только нужую для покрытия ASK часть, то есть iterable_ask_usdt_amount
                        ( slice ctx_info, int exists ) = resulting_orders_dict.udict_get?(STD_ADDR_LEN, ctx_std_addr);
                        if exists {
                            int order_id = ctx_info~load_uint(ORDER_ID_LEN);
                            int previous_coins_amount = ctx_info~load_coins();

                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(BID_ID, ORDER_ID_LEN).store_coins(iterable_ask_usdt_amount + previous_coins_amount)
                            ); 

                        } else {
                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(BID_ID, ORDER_ID_LEN).store_coins(iterable_ask_usdt_amount)
                            ); 
                        }

                        ;; мы не удаляем текущий BID, а просто его уменьшаем на iterable_ask_usdt_amount, который "откусили" от него, и конвертируем обратно в SOXO
                        int rem_soxo_amount = get_soxo(converted_ctx_soxo_bid_amount  - iterable_ask_usdt_amount);
                        ctx_bids = ctx_bids.udict_set_builder(
                            ASKS_BIDS_NUMBER_LEN, ppivot, begin_cell().store_coins(rem_soxo_amount).store_uint(ctx_std_addr, STD_ADDR_LEN)
                        ); 

                        ;; уменьшаем объём ask'a (обнуляем)
                        iterable_ask_usdt_amount -= iterable_ask_usdt_amount;

                        pack_asks_bids(ctx_priority, asks, asks_number, ask_id, ctx_bids, ctx_bids_number, ctx_bid_id);

                        ;; выходим из цикла, так как мы уже покрыли ASK
                        success = FALSE;
                        ;; заканчиваем и глобальный цикл, который перебирает приоритеты
                        ctx_priority = PRIORITIES_NUMBER + 42;
                    }
                }
                
            } until( ~ success );

        }

        ctx_priority += 1;
    }
   

    return ( resulting_orders_dict, iterable_ask_usdt_amount );

}


() add_ask( int priority, slice ask_address, int ask_jetton_amount, int qi ) impure {

    throw_unless(error::min_ask, ask_jetton_amount > MIN_USDT_ASK);
    glob::usdt_balance += ask_jetton_amount;

    ;; делаем decimals USDT 9, как у жетона SOXO 
    ;; (делаем его обратно 6 только перед отправкой в сеть), то есть если ORDER_ID == BID_ID, то делим отправляемый amount на 1000
    ask_jetton_amount *= USDT_MULTIPLIER; 

    cell resulting_orders_dict = new_dict();

    ( resulting_orders_dict, int remaining_ask_amount ) = check_bids(resulting_orders_dict, ask_jetton_amount);

    ( _, int ask_address_std ) = parse_std_addr(ask_address);

    if remaining_ask_amount > 0 { ;; еслмы мы покырли ask не полностью, то нужно добавить его в словарь ASK'ов
        ( cell asks, int asks_number, int ask_id, cell bids, int bids_number, int bid_id ) = extract_asks_bids(priority);
        asks = asks.udict_set_builder(
            ASKS_BIDS_NUMBER_LEN, asks_number, 
            begin_cell().store_coins(remaining_ask_amount).store_uint(ask_address_std, STD_ADDR_LEN)
        ); 
        ask_id += 1;
        asks_number += 1;
        pack_asks_bids(priority, asks, asks_number, ask_id, bids, bids_number, bid_id);
    }

    ifnot resulting_orders_dict.dict_empty?() == TRUE { ;; если после попытки разрешить ASK словарь сделок не пустой, тогда исполянем всё, что там есть

        ;; также добавляем в словарь сделок, которые надо исполнить того, кто сделал ASK. отдаём ему SOXO за его USDT, которые удалось прокрыть BID'ами при изначальной проверке
        int soxo_amount_to_asker = get_soxo(ask_jetton_amount - remaining_ask_amount); 
        resulting_orders_dict = resulting_orders_dict.udict_set_builder(
            STD_ADDR_LEN, ask_address_std, 
            begin_cell().store_uint(ASK_ID, ORDER_ID_LEN).store_coins(soxo_amount_to_asker)
        ); 

        execute_orders(resulting_orders_dict, qi); ;; исполняем все ордера!
    }
}

( cell, int ) check_asks( cell resulting_orders_dict, int bid_soxo_amount ) impure {

    int ctx_priority = 1;
    int iterable_bid = get_usdt(bid_soxo_amount);

    while ( ctx_priority <= PRIORITIES_NUMBER ) {
        ( cell ctx_asks, int ctx_asks_number, int ctx_ask_id, cell bids, int bids_number, int bid_id ) = extract_asks_bids(ctx_priority);

        if ctx_asks_number != 0 {

            int ppivot = -1;
            int success = TRUE;

            do {
                ( ppivot, slice ask_info, success ) = ctx_asks.udict_get_next?(ASKS_BIDS_NUMBER_LEN, ppivot);

                if success {
                    int ctx_ask_usdt_amount = ask_info~load_coins();
                    int ctx_std_addr = ask_info~load_uint(STD_ADDR_LEN);
                    int converted_ctx_ask_usdt_amount = get_soxo(ctx_ask_usdt_amount);

                    int dist = iterable_bid - ctx_ask_usdt_amount;

                    if dist == 0 {

                        ( slice ctx_info, int exists ) = resulting_orders_dict.udict_get?(STD_ADDR_LEN, ctx_std_addr);
                        if exists {
                            int order_id = ctx_info~load_uint(ORDER_ID_LEN);
                            int previous_coins_amount = ctx_info~load_coins();

                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(order_id, ORDER_ID_LEN).store_coins(converted_ctx_ask_usdt_amount + previous_coins_amount)
                            ); 

                        } else {
                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(ASK_ID, ORDER_ID_LEN).store_coins(converted_ctx_ask_usdt_amount)
                            ); 
                        }

                        ( ctx_asks, int suc ) = ctx_asks.udict_delete?(ASKS_BIDS_NUMBER_LEN, ppivot);
                        throw_unless(error:no_comments, suc);

                        ctx_asks_number -= 1;

                        iterable_bid -= ctx_ask_usdt_amount;
                        pack_asks_bids(ctx_priority, ctx_asks, ctx_asks_number, ctx_ask_id, bids, bids_number, bid_id);

                        success = FALSE;
                        ctx_priority = PRIORITIES_NUMBER + 42;
                    } elseif dist > 0 {  
                        ( slice ctx_info, int exists ) = resulting_orders_dict.udict_get?(STD_ADDR_LEN, ctx_std_addr);
                        if exists {
                            int order_id = ctx_info~load_uint(ORDER_ID_LEN);
                            int previous_coins_amount = ctx_info~load_coins();

                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(order_id, ORDER_ID_LEN).store_coins(converted_ctx_ask_usdt_amount + previous_coins_amount)
                            ); 

                        } else {
                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(ASK_ID, ORDER_ID_LEN).store_coins(converted_ctx_ask_usdt_amount)
                            ); 
                        }

                        ( ctx_asks, int suc ) = ctx_asks.udict_delete?(ASKS_BIDS_NUMBER_LEN, ppivot);
                        throw_unless(error:no_comments, suc);

                        ctx_asks_number -= 1;

                        iterable_bid -= ctx_ask_usdt_amount;
                        pack_asks_bids(ctx_priority, ctx_asks, ctx_asks_number, ctx_ask_id, bids, bids_number, bid_id);

                    } else { 
                        ( slice ctx_info, int exists ) = resulting_orders_dict.udict_get?(STD_ADDR_LEN, ctx_std_addr);
                        if exists {
                            int order_id = ctx_info~load_uint(ORDER_ID_LEN);
                            int previous_coins_amount = ctx_info~load_coins();

                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(order_id, ORDER_ID_LEN).store_coins(get_soxo(iterable_bid) + previous_coins_amount)
                            ); 

                        } else {
                            resulting_orders_dict = resulting_orders_dict.udict_set_builder(
                                STD_ADDR_LEN, ctx_std_addr, 
                                begin_cell().store_uint(ASK_ID, ORDER_ID_LEN).store_coins(get_soxo(iterable_bid))
                            ); 
                        }
                        
                        ctx_asks = ctx_asks.udict_set_builder(
                            ASKS_BIDS_NUMBER_LEN, ppivot, 
                            begin_cell().store_coins(ctx_ask_usdt_amount - iterable_bid).store_uint(ctx_std_addr, STD_ADDR_LEN)
                        ); 

                        iterable_bid -= iterable_bid;
                        pack_asks_bids(ctx_priority, ctx_asks, ctx_asks_number, ctx_ask_id, bids, bids_number, bid_id);

                        success = FALSE;
                        ctx_priority = PRIORITIES_NUMBER + 42;
                    }
                }
            } until( ~ success );
        }

        ctx_priority += 1;
        
    } 

    return ( resulting_orders_dict, get_soxo(iterable_bid) );
}

() add_bid( int priority, slice bid_address, int bid_soxo_amount, int qi ) impure {

    glob::soxo_jetton_balance += bid_soxo_amount;

    cell resulting_orders_dict = new_dict();

    ( resulting_orders_dict, int remaining_bid_amount ) = check_asks(resulting_orders_dict, bid_soxo_amount);

    ( _, int bid_address_std ) = parse_std_addr(bid_address);

    if remaining_bid_amount > 0 {
        ( cell asks, int asks_number, int ask_id, cell bids, int bids_number, int bid_id ) = extract_asks_bids(priority);
        bids = bids.udict_set_builder(
            ASKS_BIDS_NUMBER_LEN, bids_number, 
            begin_cell().store_coins(remaining_bid_amount).store_uint(bid_address_std, STD_ADDR_LEN)
        ); 
        bid_id += 1;
        bids_number += 1;
        pack_asks_bids(priority, asks, asks_number, ask_id, bids, bids_number, bid_id);
    }

    ifnot resulting_orders_dict.dict_empty?() == TRUE {

        int usdt_amount_to_bider = get_usdt(bid_soxo_amount - remaining_bid_amount); 
    
        resulting_orders_dict = resulting_orders_dict.udict_set_builder(
            STD_ADDR_LEN, bid_address_std, 
            begin_cell().store_uint(BID_ID, ORDER_ID_LEN).store_coins(usdt_amount_to_bider)
        ); 
        execute_orders(resulting_orders_dict, qi); ;; исполняем все ордера!
    }
}

() init_order_queues( ) impure {
    int ctx_priority = 1;
    repeat(PRIORITIES_NUMBER) {
        pack_asks_bids(ctx_priority, new_dict(), 0, 0, new_dict(), 0, 0);
        ctx_priority += 1;
    }
}


() recv_internal( int my_balance, int msg_value, cell in_msg_full, slice in_msg_body ) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    slice recv_msg = in_msg_full.begin_parse();
    int msg_flags = recv_msg~load_msg_flags();

    if (is_bounced(msg_flags)) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = recv_msg~load_msg_addr();

    int init? = load_globals();

    ( int op_code, int query_id ) = in_msg_body~load_op_and_query_id();

    if ~ init? {
        throw_unless(403, equal_slices_bits(init::book_minter_address, sender_address));
        if op_code == op::minter_book_init {
            init_order_queues();
            glob::usdt_master_address   = in_msg_body~load_msg_addr();
            glob::soxo_master_address   = in_msg_body~load_msg_addr();
            glob::usdt_balance          = 0;
            glob::soxo_jetton_balance   = 0;
            glob::trading_session_price = 0;
            set_globals();
            return ();
        }
    }

    if op_code == op::jetton_transfer_notification {
        throw_if(error::freezed, glob::ffreeze == TRUE);

        int msg_jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        in_msg_body~skip_bits(1);

        slice inner_payload = in_msg_body~load_ref().begin_parse();
        int inner_op = inner_payload~load_op();

        ;; TODO: verification
        int priority = inner_payload~load_uint(ORDER_QUEUES_KEY_LEN);

        if inner_op == op::ob::make_ask {
            ;; usdt::calculate_jetton_wallet_address
            slice ctx_usdt_jw = soxo::calculate_user_jetton_wallet_address(my_address(), glob::usdt_master_address, init::usdt_wallet_code);

            throw_unless(error::not_usdt_jetton, equal_slices_bits(sender_address, ctx_usdt_jw));
            add_ask(priority, from_address, msg_jetton_amount, query_id);
            set_globals();
            return ();
        }

        if inner_op == op::ob::make_bid {
            slice ctx_soxo_jw = soxo::calculate_user_jetton_wallet_address(my_address(), glob::soxo_master_address, init::soxo_wallet_code);

            throw_unless(error::not_soxo_jetton, equal_slices_bits(sender_address, ctx_soxo_jw));
            add_bid(priority, from_address, msg_jetton_amount, query_id);
            set_globals();
            return ();
        }
    }

    ;; new trading session price from backend
    if op_code == op::ob::recv_new_session {
        throw_unless(error::forbitten, equal_slices_bits(sender_address, init::admin_address));
        glob::trading_session_price = in_msg_body~load_coins();
        set_globals();
        return ();
    }

    if op_code == op::ob::fix_balances {
        throw_unless(error::forbitten, equal_slices_bits(sender_address, init::admin_address));
        glob::usdt_balance = in_msg_body~load_coins();
        glob::soxo_jetton_balance = in_msg_body~load_coins();
        set_globals();
        return ();
    }

    if op_code == op::ob::freeze {
        throw_unless(error::forbitten, equal_slices_bits(sender_address, init::admin_address));
        glob::ffreeze = in_msg_body~load_int(FFREZE_LEN);
        set_globals();
        return ();
    }

    if op_code == op::ob::change_admin {
        throw_unless(error::forbitten, equal_slices_bits(sender_address, init::admin_address));
        init::admin_address = in_msg_body~load_msg_addr();
        set_globals();
        return ();
    }


    throw(op::unknown_op);
}

( int, int, int ) get_order_book_prices( ) method_id {
    load_globals();

    return (
        glob::usdt_balance,
        glob::soxo_jetton_balance,
        glob::trading_session_price
    );

}

( slice, slice, slice, slice, slice ) get_order_book_addresses( ) method_id {
    load_globals();
    return (
        init::owner_address,
        init::admin_address,
        init::book_minter_address,

        glob::usdt_master_address,
        glob::soxo_master_address
    );
}

cell get_porder_queues() method_id {
    load_globals();
    return glob::porder_queues;
}